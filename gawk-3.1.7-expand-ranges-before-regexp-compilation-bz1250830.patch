From 0f15d2ed03785eedd5320ae579ceddc6d15df4f5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?David=20Ka=C5=A1par=20=5BDee=27Kej=5D?= <dkaspar@redhat.com>
Date: Wed, 23 Sep 2015 15:33:11 +0200
Subject: [PATCH] Backport of upstream changes to resolve #BZ1250830.

  Solves the issue where search with '[A-Z]' range would match the
  lowercase characters as well. That behaviour is no longer default for
  upstream versions of 'gawk' or 'grep'. To enable such behaviour again,
  '--posix' argument is required.

  The patch was extracted from these 4 upstream commits:
  ------------------------------------------------
  Commit: 2c126c4972966714e2c3af8826c4161c30570041
  Author: Arnold D. Robbins <arnold@skeeve.com>
  Date:   2011-05-29 22:51:44 +0300

      Fixes in expand_range.
  ------------------------------------------------
  Commit: 00d797090ffd9dcc7b1a8fa729c542846ab0242b
  Author: Arnold D. Robbins <arnold@skeeve.com>
  Date:   2011-02-07 22:36:38 +0200

      Regex bug fix and token bug fix. See ChangeLog.
  ------------------------------------------------
  Commit: 74b4f4e5a35f07bc17092e8c9ee01ba77cc8175d
  Author: Arnold D. Robbins <arnold@skeeve.com>
  Date:   2010-12-13 20:21:22 +0200

      Expand ranges before compiling the regexp.
  ------------------------------------------------
  Commit: 6f3612539c425da2bc1d34db621696e6a273b01c
  Author: Arnold D. Robbins <arnold@skeeve.com>
  Date:   2010-11-18 23:00:31 +0200

      Bring latest byte code gawk into git. Hurray!
---
 ChangeLog         |  21 ++++++
 doc/gawk.1        |   4 +-
 doc/gawk.texi     |  72 +++++++++++++++-----
 re.c              | 196 ++++++++++++++++++++++++++++++++++++++++++++++++++----
 test/ChangeLog    |   9 +++
 test/Makefile.am  |   4 +-
 test/Makefile.in  |   9 ++-
 test/Maketests    |   5 ++
 test/localenl.sh  |   2 +-
 test/negrange.awk |   7 ++
 test/negrange.ok  |   7 ++
 11 files changed, 301 insertions(+), 35 deletions(-)
 create mode 100644 test/negrange.awk
 create mode 100644 test/negrange.ok

diff --git a/ChangeLog b/ChangeLog
index 1428529..fb352b6 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,24 @@
+Sun May 29 22:48:41 2011  Arnold D. Robbins  <arnold@skeeve.com>
+
+	* re.c (expand_range): Handle cases where expanded range
+	includes '\\' (and ']'). Thanks to Juergen Daubert <jue@jue.li>.
+	Fatal error if end point is below start point ([z-a]),
+	thanks to John Haque.  Don't repeat the last character in
+	the expansion. Thanks to Arnold Robbins.
+
+Mon Feb  7 11:23:33 2011  Arnold D. Robbins  <arnold@skeeve.com>
+
+	* re.c (expand_range): Allow for ^ as first character
+	inside range. Thanks for Nelson Beebe for the bug report.
+
+Mon Dec 13 17:12:44 2010  Arnold D. Robbins  <arnold@skeeve.com>
+
+	If not POSIX, turn [d-h] into [defgh].
+
+	* re.c (expand_range): New routine to expand ranges.
+	(make_regexp): Check if might have range and call expand_range.
+	(add_char): New helper function for expand_range.
+
 Tue Jul 21 22:28:56 2009  Arnold D. Robbins  <arnold@skeeve.com>
 
 	* Release 3.1.7: Release tar file made.
diff --git a/doc/gawk.1 b/doc/gawk.1
index 2e8c31c..0da49bc 100644
--- a/doc/gawk.1
+++ b/doc/gawk.1
@@ -1621,7 +1621,9 @@ Only \*(PX regular expressions are supported, the \*(GN operators are not specia
 .B \ew
 matches a literal
 .BR w ).
-Interval expressions are allowed.
+Interval expressions are allowed. PLEASE NOTE that the regular expression
+\fB[A-Z]\fR will also match the lowercase characters in this case! Consult the
+info pages of \fB gawk \fR utility for more information about this behaviour.
 .TP
 .B \-\^\-traditional
 Traditional Unix
diff --git a/doc/gawk.texi b/doc/gawk.texi
index 83513b9..be35cad 100644
--- a/doc/gawk.texi
+++ b/doc/gawk.texi
@@ -3909,30 +3909,67 @@ occur often in practice, but it's worth noting for future reference.
 Modern systems support the notion of @dfn{locales}: a way to tell
 the system about the local character set and language.  The current
 locale setting can affect the way regexp matching works, often
-in surprising ways.  In particular, many locales do case-insensitive
-matching, even when you may have specified characters of only
-one particular case.
+in surprising ways.
 
-The following example uses the @code{sub} function, which
-does text replacement
-(@pxref{String Functions}).
-Here, the intent is to remove trailing uppercase characters:
+For example, in the default @code{"C"} locale, @samp{[a-dx-z]} is equivalent to
+@samp{[abcdxyz]}.  Many locales sort characters in dictionary order,
+and in these locales, @samp{[a-dx-z]} is typically not equivalent to
+@samp{[abcdxyz]}; instead it might be equivalent to @samp{[aBbCcdXxYyz]},
+for example.
+
+This point needs to be emphasized: Much literature teaches that one should
+use @samp{[a-z]} to match a lower case character.  But on systems with
+non-ASCII locales, this also matches all of the upper case characters
+except @samp{Z}!  This is a continuous cause of confusion, even well
+into the twenty-first century.
+
+@quotation NOTE
+In an attempt to end the confusion once and for all,
+when not in POSIX mode (@pxref{Options}),
+@command{gawk} expands ranges into the characters they
+include, based only on the machine character set.
+This restores the traditional, pre-POSIX, pre-locales
+behavior.
+
+You can use the @option{--posix} parameter in case you need the behaviour of
+pre-2008 versions of POSIX -- which is the matching of lowercase characters
+with the @samp{[A-Z]} regular expression. However, the 2008 and newer versions
+of POSIX standard changed the definition of ranges. @footnote{See the
+@uref{http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05,
+new POSIX standard} and
+@uref{http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap09.html#tag_21_09_03_05,
+its rationale}.} As a result, the @option{--posix} parameter will not work in
+the newer versions of the @command{gawk}.
+
+Therefore, you should read the rest of this section
+so that you can write portable scripts, instead of relying
+on behavior specific to @command{gawk}.
+@end quotation
+
+To obtain the traditional interpretation of bracket expressions, you can
+use the @code{"C"} locale by setting the @env{LC_ALL} environment variable to the
+value @samp{C}.  However, it is best to just use POSIX character classes,
+such as @samp{[[:lower:]]} to match specific classes of characters.
+
+To demonstrate these issues, the following example uses the @code{sub()}
+function, which does text replacement (@pxref{String Functions}).  Here,
+the intent is to remove trailing uppercase characters:
 
 @example
-$ echo something1234abc | gawk '@{ sub("[A-Z]*$", ""); print @}'
-@print{} something1234
+$ @kbd{echo something1234abc | gawk --posix '@{ sub("[A-Z]*$", ""); print @}'}
+@print{} something1234a
 @end example
 
 @noindent
-This output is unexpected, since the @samp{abc} at the end of @samp{something1234abc}
-should not normally match @samp{[A-Z]*}.  This result is due to the
-locale setting (and thus you may not see it on your system).
-There are two fixes.  The first is to use the POSIX character
-class @samp{[[:upper:]]}, instead of @samp{[A-Z]}.
+This output is unexpected, since the @samp{bc} at the end of
+@samp{something1234abc} should not normally match @samp{[A-Z]*}.
+This result is due to the locale setting (and thus you may not see
+it on your system).  There are two fixes.  The first is to use the
+POSIX character class @samp{[[:upper:]]}, instead of @samp{[A-Z]}.
 (This is preferred, since then your program will work everywhere.)
-The second is to change the locale setting in the environment,
-before running @command{gawk},
-by using the shell statements:
+
+The second is to change the locale setting in the environment, before
+running @command{gawk}, by using the shell statements:
 
 @example
 LANG=C LC_ALL=C
@@ -3950,6 +3987,7 @@ Unicode locales, such as @samp{en_US.UTF-8}.  (In general, such
 ranges should be avoided; either list the characters individually,
 or use a POSIX character class such as @samp{[[:punct:]]}.)
 
+An additional factor relates to splitting recoreds.
 For the normal case of @samp{RS = "\n"}, the locale is largely irrelevant.
 For other single-character record separators, using @samp{LC_ALL=C}
 will give you much better performance when reading records.  Otherwise,
diff --git a/re.c b/re.c
index 87888c5..6d251c9 100644
--- a/re.c
+++ b/re.c
@@ -26,6 +26,7 @@
 #include "awk.h"
 
 static reg_syntax_t syn;
+static char *expand_range(char *s, size_t *len);
 
 /* make_regexp --- generate compiled regular expressions */
 
@@ -35,13 +36,17 @@ make_regexp(const char *s, size_t len, int ignorecase, int dfa)
 	Regexp *rp;
 	const char *rerr;
 	const char *src = s;
-	char *temp;
+	char *buf = NULL;
+	size_t buflen;
 	const char *end = s + len;
 	register char *dest;
 	register int c, c2;
 	static short first = TRUE;
 	static short no_dfa = FALSE;
 	int has_anchor = FALSE;
+	int may_have_range = 0;
+	char *newbuf;
+	size_t newlen;
 
 	/* The number of bytes in the current multibyte character.
 	   It is 0, when the current character is a singlebyte character.  */
@@ -61,12 +66,13 @@ make_regexp(const char *s, size_t len, int ignorecase, int dfa)
 	/* Handle escaped characters first. */
 
 	/*
-	 * Build a copy of the string (in dest) with the
+	 * Build a copy of the string (in buf) with the
 	 * escaped characters translated, and generate the regex
-	 * from that.  
+	 * from that. 
 	 */
-	emalloc(dest, char *, len + 2, "make_regexp");
-	temp = dest;
+	emalloc(buf, char *, len + 2, "make_regexp");
+	dest = buf;
+	buflen = len;
 
 	while (src < end) {
 #ifdef MBS_SUPPORT
@@ -141,13 +147,35 @@ make_regexp(const char *s, size_t len, int ignorecase, int dfa)
 			c = *src;
 			if (c == '^' || c == '$')
 				has_anchor = TRUE;
+			if (c == '[' || c == '-' || c == ']')
+				may_have_range++;
+
 			*dest++ = *src++;	/* not '\\' */
 		}
 		if (gawk_mb_cur_max > 1 && is_multibyte)
 			is_multibyte--;
 	} /* while */
 
-	*dest = '\0' ;	/* Only necessary if we print dest ? */
+	*dest = '\0';
+	len = dest - buf;
+
+	if (   ! do_posix
+	    && may_have_range >= 3
+	    && memchr(buf, '-', len) != NULL) {
+		newlen = len;
+		newbuf = expand_range(buf, & newlen);
+
+		if (newlen > buflen) {
+			free(buf);
+			buf = newbuf;
+			buflen = newlen;
+		} else {
+			memcpy(buf, newbuf, newlen);
+			free(newbuf);
+		}
+		len = newlen;
+	}
+
 	emalloc(rp, Regexp *, sizeof(*rp), "make_regexp");
 	memset((char *) rp, 0, sizeof(*rp));
 	rp->pat.allocated = 0;	/* regex will allocate the buffer */
@@ -184,20 +212,19 @@ make_regexp(const char *s, size_t len, int ignorecase, int dfa)
 	dfasyntax(syn | (ignorecase ? RE_ICASE : 0), ignorecase ? TRUE : FALSE, '\n');
 	re_set_syntax(syn);
 
-	len = dest - temp;
-	if ((rerr = re_compile_pattern(temp, len, &(rp->pat))) != NULL)
-		fatal("%s: /%s/", rerr, temp);	/* rerr already gettextized inside regex routines */
+	if ((rerr = re_compile_pattern(buf, len, &(rp->pat))) != NULL)
+		fatal("%s: /%s/", rerr, buf);	/* rerr already gettextized inside regex routines */
 
 	/* gack. this must be done *after* re_compile_pattern */
 	rp->pat.newline_anchor = FALSE; /* don't get \n in middle of string */
 	if (dfa && ! no_dfa) {
-		dfacomp(temp, len, &(rp->dfareg), TRUE);
+		dfacomp(buf, len, &(rp->dfareg), TRUE);
 		rp->dfa = TRUE;
 	} else
 		rp->dfa = FALSE;
 	rp->has_anchor = has_anchor;
-
-	free(temp);
+ 
+	free(buf);
 	return rp;
 }
 
@@ -239,7 +266,7 @@ research(Regexp *rp, register char *str, int start,
 	if (rp->dfa && ! no_bol && ! need_start) {
 		char save;
 		int count = 0;
- 		/*
+		/*
 		 * dfa likes to stick a '\n' right after the matched
 		 * text.  So we just save and restore the character.
 		 */
@@ -288,7 +315,7 @@ refree(Regexp *rp)
 		dfafree(&(rp->dfareg));
 	free(rp);
 }
- 
+
 /* dfaerror --- print an error message for the dfa routines */
 
 void
@@ -461,3 +488,144 @@ reflags2str(int flagval)
 
 	return genflags2str(flagval, values);
 }
+
+/* add_char --- add a character to the buffer, grow it if needed */
+
+static void
+add_char(char **bufp, size_t *lenp, char ch, char **ptr)
+{
+	size_t newlen;
+	size_t offset;
+
+	if (*ptr - *bufp < *lenp) {
+		**ptr = ch;
+		(*ptr)++;
+		return;
+	}
+
+	/* have to grow the buffer and adjust the pointers */
+	offset = (*ptr - *bufp);
+	newlen = offset * 2;
+	erealloc(*bufp, char *, newlen + 2, "add_char");
+	*ptr = *bufp + offset;
+	**ptr = ch;
+	*lenp = newlen + 2;
+	(*ptr)++;
+}
+
+/* expand_range --- turn [b-e] into [bcde] */
+
+static char *
+expand_range(char *s, size_t *lenp)
+{
+	int i;
+	int found = FALSE;
+	char *sp, *sp2, *newbuf;
+	size_t len;
+	int count = 0;
+	size_t newbuf_len = *lenp * 2;
+
+	emalloc(newbuf, char *, newbuf_len, "expand_range");
+
+	sp = s;
+	sp2 = newbuf;
+	len = *lenp;
+#define copy() (add_char(& newbuf, & newbuf_len, *sp++, & sp2), len--)
+#define copych(ch) (add_char(& newbuf, & newbuf_len, ch, & sp2))
+again:
+	while (len > 0) {
+		if (*sp == '\\') {
+			copy();
+			copy();
+		}
+		else if (*sp == '[') {
+			count++;
+			break;
+		}
+		else
+			copy();
+	}
+	if (len == 0)
+		goto done;
+
+	copy();		/* copy in the [ */
+	if (*sp == '^')	/* allow for negation of range */
+		copy();
+
+	/*
+	 * Minus as first character after [ or ^ is literal,
+	 * just copy it and skip over.
+	 */
+	if (*sp == '-')
+		copy();
+
+	while (count > 0 && len > 0) {
+		if (*sp == '\\') {
+			copy();
+			copy();
+			continue;
+		}
+		if (*sp == '[') {
+			count++;
+			copy();
+			continue;
+		}
+		if (*sp == ']') {
+			count--;
+			copy();
+			if (count == 0)
+				goto again;
+			else
+				continue;
+		}
+
+		if (count == 1) {
+			/* inside [...] but not inside [[:...:]] */
+			if (*sp == '-') {
+				int start, end;
+				int i;
+
+				if (sp[1] == ']') {	/* also literal */
+					copy();
+					continue;
+				}
+
+				/* It's a range, expand it. */
+				start = sp[-1];
+				if (sp[1] == '\\') {
+					sp++;
+					len--;
+				}
+				end = sp[1];
+				if (end < start)
+					fatal(_("Invalid range end: /%.*s/"),
+								*lenp, s);
+				for (i = start + 1; i < end; i++) {
+					/*
+					 * Will the special cases never end?
+					 */
+					if (i == '\\' || i == ']') {
+						copych('\\');
+					}
+					copych(i);
+				}
+				sp++;
+				len--;
+				continue;
+			}
+			else
+				copy();
+		} else {
+			copy();
+		}
+	}
+
+	if (len > 0)
+		goto again;
+
+done:
+	*lenp = sp2 - newbuf;
+	return newbuf;
+}
+#undef copy
+#undef copych
diff --git a/test/ChangeLog b/test/ChangeLog
index 2b818b6..659e8e0 100644
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,3 +1,12 @@
+Mon Feb  7 21:39:39 2011  Arnold D. Robbins  <arnold@skeeve.com>
+
+	* Makefile.am (negrange): New test.
+	* negrange.awk, negrange.ok: New files.
+
+Mon Dec 13 13:54:56 2010  Arnold D. Robbins  <arnold@skeeve.com>
+
+	* localenl.sh: Use --posix option.
+
 Tue Jul 21 22:28:56 2009  Arnold D. Robbins  <arnold@skeeve.com>
 
 	* Release 3.1.7: Release tar file made.
diff --git a/test/Makefile.am b/test/Makefile.am
index cea095f..be0ec4e 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -378,6 +378,8 @@ EXTRA_DIST = \
 	nasty2.ok \
 	negexp.awk \
 	negexp.ok \
+	negrange.awk \
+	negrange.ok \
 	nested.awk \
 	nested.in \
 	nested.ok \
@@ -694,7 +696,7 @@ BASIC_TESTS = \
 	gsubasgn gsubtest gsubtst2 gsubtst3 gsubtst4 gsubtst5 gsubtst6 \
 	hex hsprint inputred intest intprec iobug1 leaddig leadnl litoct \
 	longsub longwrds manglprm math membug1 messages minusstr mmap8k \
-	mtchi18n nasty nasty2 negexp nested nfldstr nfneg nfset nlfldsep \
+	mtchi18n nasty nasty2 negexp negrange nested nfldstr nfneg nfset nlfldsep \
 	nlinstr nlstrina noeffect nofile nofmtch noloop1 noloop2 nonl noparms \
 	nors nulrsend numindex numsubstr octsub ofmt ofmtbig ofmtfidl ofmts \
 	onlynl opasnidx opasnslf paramdup paramres paramtyp parse1 parsefld \
diff --git a/test/Makefile.in b/test/Makefile.in
index 7506180..2482a8b 100644
--- a/test/Makefile.in
+++ b/test/Makefile.in
@@ -578,6 +578,8 @@ EXTRA_DIST = \
 	nasty2.ok \
 	negexp.awk \
 	negexp.ok \
+	negrange.awk \
+	negrange.ok \
 	nested.awk \
 	nested.in \
 	nested.ok \
@@ -894,7 +896,7 @@ BASIC_TESTS = \
 	gsubasgn gsubtest gsubtst2 gsubtst3 gsubtst4 gsubtst5 gsubtst6 \
 	hex hsprint inputred intest intprec iobug1 leaddig leadnl litoct \
 	longsub longwrds manglprm math membug1 messages minusstr mmap8k \
-	mtchi18n nasty nasty2 negexp nested nfldstr nfneg nfset nlfldsep \
+	mtchi18n nasty nasty2 negexp negrange nested nfldstr nfneg nfset nlfldsep \
 	nlinstr nlstrina noeffect nofile nofmtch noloop1 noloop2 nonl noparms \
 	nors nulrsend numindex numsubstr octsub ofmt ofmtbig ofmtfidl ofmts \
 	onlynl opasnidx opasnslf paramdup paramres paramtyp parse1 parsefld \
@@ -2029,6 +2031,11 @@ negexp:
 	@AWKPATH=$(srcdir) $(AWK) -f $@.awk  >_$@ 2>&1 || echo EXIT CODE: $$? >>_$@
 	@-$(CMP) $(srcdir)/$@.ok _$@ && rm -f _$@
 
+negrange:
+	@echo negrange
+	@AWKPATH=$(srcdir) $(AWK) -f $@.awk  >_$@ 2>&1 || echo EXIT CODE: $$? >>_$@
+	@-$(CMP) $(srcdir)/$@.ok _$@ && rm -f _$@
+
 nested:
 	@echo nested
 	@AWKPATH=$(srcdir) $(AWK) -f $@.awk  < $(srcdir)/$@.in >_$@ 2>&1 || echo EXIT CODE: $$? >>_$@
diff --git a/test/Maketests b/test/Maketests
index 0da281d..1da2211 100644
--- a/test/Maketests
+++ b/test/Maketests
@@ -405,6 +405,11 @@ negexp:
 	@AWKPATH=$(srcdir) $(AWK) -f $@.awk  >_$@ 2>&1 || echo EXIT CODE: $$? >>_$@
 	@-$(CMP) $(srcdir)/$@.ok _$@ && rm -f _$@
 
+negrange:
+	@echo negrange
+	@AWKPATH=$(srcdir) $(AWK) -f $@.awk  >_$@ 2>&1 || echo EXIT CODE: $$? >>_$@
+	@-$(CMP) $(srcdir)/$@.ok _$@ && rm -f _$@
+
 nested:
 	@echo nested
 	@AWKPATH=$(srcdir) $(AWK) -f $@.awk  < $(srcdir)/$@.in >_$@ 2>&1 || echo EXIT CODE: $$? >>_$@
diff --git a/test/localenl.sh b/test/localenl.sh
index 2c7e78c..34ca415 100755
--- a/test/localenl.sh
+++ b/test/localenl.sh
@@ -49,7 +49,7 @@ line7
 line8
 line9
 EOF
-$AWK '
+$AWK --posix '
 BEGIN { RS="\0"; }
 { 
   if (match($0, /\n[^2\n]*2/)) { got2=1; } else { print "no match 2"; }
diff --git a/test/negrange.awk b/test/negrange.awk
new file mode 100644
index 0000000..a905b7f
--- /dev/null
+++ b/test/negrange.awk
@@ -0,0 +1,7 @@
+BEGIN {
+	s = "Volume 8, Numbers 1-2 / January 1971"
+        n = split(s, parts, "[^-A-Za-z0-9]+")
+	print "n =", n
+	for (i = 1; i <= n; i++)
+		printf("s[%d] = \"%s\"\n", i, parts[i])
+}
diff --git a/test/negrange.ok b/test/negrange.ok
new file mode 100644
index 0000000..57f4c8e
--- /dev/null
+++ b/test/negrange.ok
@@ -0,0 +1,7 @@
+n = 6
+s[1] = "Volume"
+s[2] = "8"
+s[3] = "Numbers"
+s[4] = "1-2"
+s[5] = "January"
+s[6] = "1971"
-- 
2.4.3

